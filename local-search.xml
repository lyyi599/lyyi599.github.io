<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>The death of the rose开发记录</title>
    <link href="/2026/02/25/The%20death%20of%20the%20rose/"/>
    <url>/2026/02/25/The%20death%20of%20the%20rose/</url>
    
    <content type="html"><![CDATA[<p>The death of the rose 开发记录。</p><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>一直想做一个小而美的软件，代办放在飞书已经两个月了。今天静下来梳理了需求，vibe coding写了一下，不得不感叹ai真好用。</p><h3 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h3><ul><li>2026-02-25：新建文件夹，和Gemini梳理需求，用Figma做了一下原型。</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rose</tag>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iDo开发笔记</title>
    <link href="/2026/02/23/ido_dev/"/>
    <url>/2026/02/23/ido_dev/</url>
    
    <content type="html"><![CDATA[<p>iDo社区的开发记录</p><h2 id="IDO"><a href="#IDO" class="headerlink" title="IDO"></a>IDO</h2><p>相较于iDo作为监督社区的原始愿景，它将进一步优化为交流社区。本文是开发记录。</p><h3 id="timeline"><a href="#timeline" class="headerlink" title="timeline"></a>timeline</h3><ul><li>2026-02-23：初步版本</li><li>before 2026-02-23：大量的初期准备</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>iDo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这里填写文章标题</title>
    <link href="/2026/01/30/template/"/>
    <url>/2026/01/30/template/</url>
    
    <content type="html"><![CDATA[<p>这里写文章的<strong>摘要</strong>（显示在首页列表里的文字）。<br>简短介绍一下这篇文章要讲什么。</p><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>从这里开始写你的正文内容。</p><h3 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h3><ul><li>列表项 1</li><li>列表项 2</li></ul><blockquote><p>这里是引用块</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="本地预览命令-Local-Debug"><a href="#本地预览命令-Local-Debug" class="headerlink" title="本地预览命令 (Local Debug)"></a>本地预览命令 (Local Debug)</h2><p><strong>场景：</strong> 写完文章后，或者修改了配置后，想在自己电脑上先看看效果，<strong>不</strong>上传到互联网。</p><p>打开博客根目录终端，依次执行：</p><h3 id="1-清理缓存-防止旧样式残留，改了配置必做"><a href="#1-清理缓存-防止旧样式残留，改了配置必做" class="headerlink" title="1. 清理缓存 (防止旧样式残留，改了配置必做)"></a>1. 清理缓存 (防止旧样式残留，改了配置必做)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl<br></code></pre></td></tr></table></figure><h3 id="2-生成静态页面"><a href="#2-生成静态页面" class="headerlink" title="2. 生成静态页面"></a>2. 生成静态页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><h3 id="3-启动本地服务器"><a href="#3-启动本地服务器" class="headerlink" title="3. 启动本地服务器"></a>3. 启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><h3 id="一行简写"><a href="#一行简写" class="headerlink" title="一行简写"></a>一行简写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h2 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h2><h3 id="1-清理缓存-保险起见"><a href="#1-清理缓存-保险起见" class="headerlink" title="1. 清理缓存 (保险起见)"></a>1. 清理缓存 (保险起见)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><h3 id="2-生成最终静态文件"><a href="#2-生成最终静态文件" class="headerlink" title="2. 生成最终静态文件"></a>2. 生成最终静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><h3 id="3-推送到-GitHub"><a href="#3-推送到-GitHub" class="headerlink" title="3. 推送到 GitHub"></a>3. 推送到 GitHub</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><h3 id="一行简写-1"><a href="#一行简写-1" class="headerlink" title="一行简写"></a>一行简写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl ; hexo g ; hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分类名称</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标签1</tag>
      
      <tag>标签2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组原 无敌版</title>
    <link href="/2022/08/12/4%20%E8%AE%A1%E7%BB%84%E6%97%A0%E6%95%8C%E7%89%88/"/>
    <url>/2022/08/12/4%20%E8%AE%A1%E7%BB%84%E6%97%A0%E6%95%8C%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>大学的遗物<br>从大学课程中的重新总结，来源于课程朱老师课程录屏</p><h1 id="一、引论"><a href="#一、引论" class="headerlink" title="一、引论"></a>一、引论</h1><h2 id="计算机功能部件"><a href="#计算机功能部件" class="headerlink" title="计算机功能部件"></a>计算机功能部件</h2><p>计算机的基本功能：数据加工、数据保存、数据传送、操作控制。相应的有硬件的五大部件，他们组成了计算机系统的体系结构。</p><p><img src="/../img/4_image/1.png" alt="1-1"></p><blockquote><ol><li><p>存储器分为主存储器（内存、外存）和辅助存储器（外存、辅存）</p></li><li><p>存储器的访问方式</p><ul><li>按地址进行访问</li><li>按内容进行访问（相联存储器）</li></ul></li><li><p>主存的基本组成</p><p><img src="/../img/4_image/2.png" alt="1-2"></p></li></ol></blockquote><p>程序：解题步骤，控制器按照事先安排好的步骤，控制计算机各个部件有条不紊的自动工作。</p><p>程序按照指令序列的形式存放在存储器中，控制器一次读出存储器中的程序质量实施控制。这种方式叫做<strong>存储程序方式</strong></p><p>早期冯·诺伊曼计算机<strong>以运算器为中心</strong>，现代计算机逐步转变为<strong>以存储器为中心</strong></p><p>现代计算机结构依然遵循冯诺依曼思想。</p><h2 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h2><p>基本的软件系统包含<strong>系统软件</strong> 和<strong>应用软件</strong>两大类</p><h2 id="计算机系统的组织结构"><a href="#计算机系统的组织结构" class="headerlink" title="计算机系统的组织结构"></a>计算机系统的组织结构</h2><p>硬件、软件在逻辑功能上是等价的。</p><p>计算机系统结构是多层次的。</p><h3 id="计算机硬件的系统结构"><a href="#计算机硬件的系统结构" class="headerlink" title="计算机硬件的系统结构"></a>计算机硬件的系统结构</h3><p>现代计算机普遍采用总线结构</p><p>总线的使用规定：分时发送，同时接收。（发送部件需要分时使用总线发送信息，但是各个部件可以同时接收到总线的数据）</p><blockquote><p>总线的分类</p><p>按照任务：cpu内部总线、部件内部总线、系统总线、外总线</p><p>按照信息传送方向：单向总线、双向总线</p><p>按照总线的信息传送位数：串行、并行</p></blockquote><h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><ol><li>基本字长：范围和精度</li><li>主存容量：程序复杂性</li><li>运算速度</li><li>外部设备</li><li>软件配置</li></ol><h1 id="二、计算机中数据信息的表示"><a href="#二、计算机中数据信息的表示" class="headerlink" title="二、计算机中数据信息的表示"></a>二、计算机中数据信息的表示</h1><h2 id="数制与数制转换"><a href="#数制与数制转换" class="headerlink" title="数制与数制转换"></a>数制与数制转换</h2><p>进位计数值都有两个基本因素：<strong>基值</strong>，<strong>位权值</strong></p><p>任意进制转换为十进制：按权相加</p><p>十进制转换为任意进制：整数部分、小数部分分别进行转换，整数部分除基取余（逆序），小数部分乘基取整（顺序）</p><h2 id="带符号数的表示"><a href="#带符号数的表示" class="headerlink" title="带符号数的表示"></a>带符号数的表示</h2><h3 id="1-机器数"><a href="#1-机器数" class="headerlink" title="1. 机器数"></a>1. 机器数</h3><p>机器数是连同数字一起代码化的数据，小数点本身是隐含的。</p><p>机器数分为有符号数和无符号数，指令想知道机器数是否带符号，由指令的操作码决定。</p><p>真值&#x3D;符号位+绝对值</p><blockquote><p>四种机器码：原码、补码、反码和移码</p></blockquote><h3 id="2-原码表示"><a href="#2-原码表示" class="headerlink" title="2.原码表示"></a>2.原码表示</h3><p>文字定义：数值部分的形式不变，只将符号用二进制代码表示</p><p>公式定义</p><p><img src="/../img/4_image/v2-e1281b0d4a6bc96dc016f17f7d16206e_720w.jpg" alt="img"></p><p><img src="/../img/4_image/v2-2f9d6c3ec1dee4160d747c535dfd3568_720w.jpg" alt="img"></p><p>原码的移位规则：符号位不变，数值部分左移或者右移，移出的空位补0。左移将有效位移出会导致移除错误。</p><h3 id="3-补码表示"><a href="#3-补码表示" class="headerlink" title="3.补码表示"></a>3.补码表示</h3><p>目的：为了解决原码的加减运算的不方便</p><p>公式定义</p><p><img src="/../img/4_image/v2-296be1d2d23f34437c39a95371c2ffc0_720w.jpg" alt="img"></p><p><img src="/../img/4_image/v2-f49d7174a04b176bc85d242a62bded34_720w.jpg" alt="img"></p><p>从定义可以看出，相对于原码的整数表数范围变大了（所表示最小值更小了）</p><blockquote><p>补码求法：对原码，<strong>符号位不变，从后面往前数到第一个1，上述不变，前面的位数全部取反</strong>。</p></blockquote><p>真值和补码的映射关系图</p><p><img src="/../img/4_image/A36868BE783D4B7056E6F2C4A02788FB.png" alt="img"></p><p>补码的移位规则：</p><ul><li>右移：符号位不变，数值位右移，高位补符号位</li><li>左移：连同符号位左移，低位补0，注意会溢出</li></ul><blockquote><p>补码的模</p><ul><li>补码总是对于确定的模而言的。如果补码运算的结果超过了模，会自动取模</li><li>补码在运算过程中，模不可以改变</li><li>为了使得不同位数补码可以求和，需<strong>符号扩展</strong>，方法是扩充符号位</li></ul></blockquote><h3 id="4-反码表示"><a href="#4-反码表示" class="headerlink" title="4.反码表示"></a>4.反码表示</h3><p>公式定义：</p><p><img src="/../img/4_image/v2-c35c0b3f6185f83574341ef9c3f95595_720w.jpg" alt="img"></p><p><img src="/../img/4_image/v2-593c62545f376159f87452b222a78270_720w.jpg" alt="img"></p><blockquote><p>反码求法：</p><ul><li>正数不变</li><li>负数保存符号位不变，各个位取反</li></ul></blockquote><h3 id="5-移码表示"><a href="#5-移码表示" class="headerlink" title="5.移码表示"></a>5.移码表示</h3><p>移码，常用于表示浮点数的阶码。</p><blockquote><p>移码求法：整数求补，符号取反</p></blockquote><p>特殊的移码：移码&#x3D;K+实际数值。例如，移127码&#x3D;127+实际数值。</p><h3 id="6-不同码值之间的关系图"><a href="#6-不同码值之间的关系图" class="headerlink" title="6.不同码值之间的关系图"></a>6.不同码值之间的关系图</h3><p><img src="/../img/4_image/9D43F3FD1A699A18A9EB4494CE5AC238.png" alt="img"></p><h2 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h2><p>任何一个数都可以表示为以下形式<br>$$<br>(N)_R&#x3D;\pm{S*R^{\pm{e}}}<br>$$<br>其中，R（基值），S（尾数），e（阶码）</p><h3 id="1-定点表示"><a href="#1-定点表示" class="headerlink" title="1.定点表示"></a>1.定点表示</h3><p>约定阶码e不变</p><blockquote><p>定点小数：e&#x3D;0，约定小数点在符号位和最高位之间</p><p>定点整数：e&#x3D;0，约定小数点在最低有效数值位之后</p></blockquote><p>定点数的分辨率：相邻两个定点数之间的最小间隔</p><h3 id="2-浮点表示"><a href="#2-浮点表示" class="headerlink" title="2.浮点表示"></a>2.浮点表示</h3><p>浮点数由阶码和尾数两个部分组成。</p><blockquote><p>阶码表示小数点的实际位置，阶码均采用2的基数</p><p>尾数表示数的有效数字</p></blockquote><p>浮点数的规格化表示：</p><ul><li>目的<ul><li>尽可能多得保留有效数字</li><li>保证浮点的唯一性</li></ul></li><li>方法<ul><li>尽可能的去掉尾数中的前置“0”，即尽可能使二进制小数点后第一位是1，可满足1&#x2F;2&lt;&#x3D;|s|&lt;1</li></ul></li></ul><blockquote><p>规格化数的定义</p><p>原码表示规格化数： s<del>1</del>&#x3D;1$\Leftrightarrow$规格化</p><p>补码表示规格化数：s<del>f</del> $\bigoplus$ s<del>1</del>$\Leftrightarrow$规格化</p></blockquote><p>表数范围：Todo</p><h4 id="IEEE浮点数标准"><a href="#IEEE浮点数标准" class="headerlink" title="IEEE浮点数标准"></a>IEEE浮点数标准</h4><p>Todo</p><h2 id="非数值型数据的表示"><a href="#非数值型数据的表示" class="headerlink" title="非数值型数据的表示"></a>非数值型数据的表示</h2><h3 id="1-逻辑数（二进制串）"><a href="#1-逻辑数（二进制串）" class="headerlink" title="1.逻辑数（二进制串）"></a>1.逻辑数（二进制串）</h3><ul><li>无符号问题，无位权问题，无进位问题</li><li>“0”，“1”不代表大小，只代表逻辑真假</li><li>按位进行逻辑运算</li></ul><h3 id="2-汉字交换码"><a href="#2-汉字交换码" class="headerlink" title="2.汉字交换码"></a>2.汉字交换码</h3><p>区位码（区码，位码，共两字节）-&gt;国标码（两字节，但只是用低7位）-&gt;机内码（机内码&#x3D;国标码+8080H）</p><h2 id="数据的长度和存储方式"><a href="#数据的长度和存储方式" class="headerlink" title="数据的长度和存储方式"></a>数据的长度和存储方式</h2><p>位（bit），字节（Byte，B），字</p><p>字长：字中包含的二进制位数</p><p>数据的存储顺序：大端排序、小端排序</p><h2 id="数据校验码"><a href="#数据校验码" class="headerlink" title="数据校验码"></a>数据校验码</h2><p><strong>编码距离</strong>：一组编码中任何两个编码之间代码不同的位数称为编码距离，也称为海明距离。</p><p><strong>码距</strong>：在一组编码中，任何两个编码之间<strong>最小的距离</strong>称为这组编码的码距。</p><p><strong>检纠错误的位数与码距之间的关系</strong>：检错e位，需要e+1位码距；纠正t位错误，需要2t+1位码距</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>Todo</p><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>Todo</p><h3 id="扩展海明校验码"><a href="#扩展海明校验码" class="headerlink" title="扩展海明校验码"></a>扩展海明校验码</h3><p>Todo</p><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><p>Todo</p><h1 id="三、运算方法与运算器"><a href="#三、运算方法与运算器" class="headerlink" title="三、运算方法与运算器"></a>三、运算方法与运算器</h1><h2 id="运算器的设计方法"><a href="#运算器的设计方法" class="headerlink" title="运算器的设计方法"></a>运算器的设计方法</h2><p><strong>计算机中数据加工最基本的思想</strong>：将各种复杂的运算处理分解为最基本的算数运算和逻辑运算</p><h2 id="大量运算规则Todo"><a href="#大量运算规则Todo" class="headerlink" title="大量运算规则Todo"></a>大量运算规则Todo</h2><h1 id="四、存储器系统"><a href="#四、存储器系统" class="headerlink" title="四、存储器系统"></a>四、存储器系统</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><blockquote><p>主存：cpu能直接访问的存储器</p><p>辅存：cpu不能直接访问的存储器，也叫外存</p><p>高速缓冲存储器cache：用于解决cpu与主存之间速度匹配问题的高速小型存储器，存放cpu立即要使用的或者刚使用的程序或数据</p></blockquote><p><img src="/../img/4_image/98C32E2C0853743488CAA9FED0115A33.png" alt="img"></p><h4 id="存储器的编址"><a href="#存储器的编址" class="headerlink" title="存储器的编址"></a>存储器的编址</h4><p><strong>编址单位</strong>；存储器中可寻址的最小单位</p><blockquote><p>按字节编址：相邻两个单元是两个字节（字节，每个字节8位）</p><p>按字编址：相邻两个单元是两个字（字，机器字，包括若干字节，依据不同机器而定）</p><p>目前按照字节编址是主流，大量机器中使用整数边界对齐的方式</p></blockquote><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><ul><li>存储容量</li><li>访问速度</li></ul><h3 id="存储器的总线带宽"><a href="#存储器的总线带宽" class="headerlink" title="存储器的总线带宽"></a>存储器的总线带宽</h3><p>带宽：单位时间内所存取的二进制信息位数</p><blockquote><p>带宽的计算</p><p>带宽&#x3D;每个周期访问的位数&#x2F;存取周期时长</p><p>带宽&#x3D;存储器总线宽度&#x2F;存取周期时长</p></blockquote><h3 id="存储器系统的层次结构"><a href="#存储器系统的层次结构" class="headerlink" title="存储器系统的层次结构"></a>存储器系统的层次结构</h3><p><img src="/../img/4_image/594A33A6546AEC96172B0CF3BB139CBE.png" alt="img"></p><h2 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h2><p><img src="/../img/4_image/99E60DFA0788272AD76D6D2B198CAEC7.png" alt="img"></p><h3 id="半导体随机存储器芯片的结构"><a href="#半导体随机存储器芯片的结构" class="headerlink" title="半导体随机存储器芯片的结构"></a>半导体随机存储器芯片的结构</h3><blockquote><ul><li><p>字片式</p></li><li><p>位片式</p></li></ul></blockquote><h4 id="动态存储器的刷新"><a href="#动态存储器的刷新" class="headerlink" title="动态存储器的刷新"></a>动态存储器的刷新</h4><p>按行刷新</p><h3 id="半导体存储器的组成"><a href="#半导体存储器的组成" class="headerlink" title="半导体存储器的组成"></a>半导体存储器的组成</h3><p>计算组成存储器所需芯片的数量计算公式：<br>$$<br>芯片总片数&#x3D;\frac{存储器总单元数<em>位数&#x2F;单元}{每片芯片单元数</em>位数&#x2F;单元}<br>$$</p><h4 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h4><blockquote><p>含义：只进行位数扩展（增加字长）</p><p>链接方式：</p><ul><li>将所有的存储器芯片的地址线、片选信号线和读写控制线并接，连到地址和控制总线对应位</li><li>将各芯片数据线单独列出，分别接到数据总线的对应位</li></ul></blockquote><h4 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h4><blockquote><p>含义：仅仅是单元数（字数）扩展，位数不变</p><p>链接方式：</p><ul><li>将所有的存储器芯片的地址线、数据线和读写控制线并接，连到地址、数据和控制总线对应位</li><li>由片选信号区分被选芯片</li></ul></blockquote><h4 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h4><p>字和位要分别进行，注意片选信号连接方式</p><h2 id="半导体只读存储器"><a href="#半导体只读存储器" class="headerlink" title="半导体只读存储器"></a>半导体只读存储器</h2><h2 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h2><h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>cache的主要目的：速度匹配，存放主存信息的副本。</p><p>设计原理：程序的局部性原理（时间局部性和空间局部性）</p><p>设计理念：加快速度，但是对程序员透明，并且在cache中按块管理</p><p>cache的命中：欲访问主存中的数据已保存在cache中</p><p>cache命中率：$H&#x3D;\frac{N_c}{N_c+N_m}$（$N_c$总命中次数，$N_m$未命中然后访问主存次数）</p><p>cache其它参数：Todo</p><p>cache工作原理：</p><p><img src="/../img/4_image/F1E1F13EC23BA7BC7D1294D62DF97E4B.png" alt="img"></p><p>cpu访存地址：块号+块内偏移量</p><p>内容cache&#x3D;数据cache+标识cache</p><p>标识cache又是包含一位有效位，用于判断脏数据</p><h3 id="cache地址映像方式"><a href="#cache地址映像方式" class="headerlink" title="cache地址映像方式"></a>cache地址映像方式</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p>主存地址&#x3D;区号+区域块号+块内偏移量</p><p>cache地址：块号+块内偏移量</p><p>地址转换Todo</p><h4 id="全相联映像"><a href="#全相联映像" class="headerlink" title="全相联映像"></a>全相联映像</h4><p>任何主存可以映像到任意一个cache块。</p><p>地址转换Todo</p><h4 id="组相联映像"><a href="#组相联映像" class="headerlink" title="组相联映像"></a>组相联映像</h4><p>主存任何一个组只能映射到cache中的某一个固定的组，但是同一个组中的主存块可以调入cache指定组中的任意块</p><p>地址转换Todo</p><h3 id="cached-替换算法与写策略"><a href="#cached-替换算法与写策略" class="headerlink" title="cached 替换算法与写策略"></a>cached 替换算法与写策略</h3><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><blockquote><p>FIFO法（先进先出法）</p><p>LRU法（近期最少使用法）</p></blockquote><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><blockquote><p>写直达法：cpu执行写操作时，利用主存和cpu之间的直接通道，写入cache的同时也写入主存</p><p>写回法：当cpu执行写操作，只写cache不写主存，只有cache被替换，才将被修改的cache写回主存</p></blockquote><h2 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h2><h3 id="磁盘信息记录格式及其读写"><a href="#磁盘信息记录格式及其读写" class="headerlink" title="磁盘信息记录格式及其读写"></a>磁盘信息记录格式及其读写</h3><blockquote><p>相关概念</p><ul><li>记录面</li><li>磁盘</li><li>扇区</li><li>扇段</li><li>柱面</li></ul></blockquote><p>硬盘地址标识：圆柱面号+盘面号+扇区号</p><h3 id="磁盘存储的主要技术指标"><a href="#磁盘存储的主要技术指标" class="headerlink" title="磁盘存储的主要技术指标"></a>磁盘存储的主要技术指标</h3><blockquote><ul><li>存储容量C</li><li>平均存取时间&#x3D;平均磁道定位时间+平均旋转等待时间+读写操作时间+控制延时时间</li><li>存储密度<ul><li>位密度：沿着磁道方向单位长度所能存储的二进制位数目（一般内外圈不一致，以最内圈密度为准）</li><li>道密度：沿着磁道径向单位长度所包含的磁道数目</li><li>面密度&#x3D;位密度*道密度</li></ul></li><li>数据传输率：磁盘存储器单位时间能传送的数据量</li></ul></blockquote><h1 id="五、指令系统"><a href="#五、指令系统" class="headerlink" title="五、指令系统"></a>五、指令系统</h1><h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><p>指令字（指令代码）：表示一条指令的二进制代码</p><blockquote><p>一条指令应该包含的信息：</p><ul><li>操作码：表示指令的操作特性和功能</li><li>操作码的地址：指示操作数或操作数所在的地址</li><li>存放操作数的地址</li><li>下一条指令的地址</li></ul></blockquote><p>指令字的长度：单字长或双字长</p><p>指令的地址码：地址信息在指令码中明确给出的称为“显地址”，地址也可以依据某种实现的约定，用隐含的方式给出</p><p>指令的操作码：假定指令系统由m种操作，则操作码位数n应该满足n$\geq log_{2}{m}$</p><p>变长指令早期采用<strong>扩展操作码法</strong></p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>寻址分为：指令地址的寻址和操作数地址的寻址</p><h3 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h3><ul><li><p>顺序方式：pc&#x3D;pc+增量</p></li><li><p>跳跃方式：跳转</p></li></ul><h3 id="操作数的寻址方式"><a href="#操作数的寻址方式" class="headerlink" title="操作数的寻址方式"></a>操作数的寻址方式</h3><p>Todo</p><ul><li>立即寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器直接寻址</li><li>寄存器间接寻址</li><li>变址寻址</li><li>相对寻址</li><li>基址寻址</li></ul><h2 id="指令类型及功能"><a href="#指令类型及功能" class="headerlink" title="指令类型及功能"></a>指令类型及功能</h2><p>Todo</p><h1 id="六、控制系统与CPU"><a href="#六、控制系统与CPU" class="headerlink" title="六、控制系统与CPU"></a>六、控制系统与CPU</h1><h2 id="控制器概述"><a href="#控制器概述" class="headerlink" title="控制器概述"></a>控制器概述</h2><h3 id="计算机运行基本过程"><a href="#计算机运行基本过程" class="headerlink" title="计算机运行基本过程"></a>计算机运行基本过程</h3><p>取指令、分析指令、执行指令</p><h3 id="控制器的基本功能"><a href="#控制器的基本功能" class="headerlink" title="控制器的基本功能"></a>控制器的基本功能</h3><ul><li>控制指令的正确执行</li><li>控制程序和数据的输入以及结果的输出，注意，每一条指令执行完毕后，才判定是否有异常中断</li></ul><h3 id="控制器的组成"><a href="#控制器的组成" class="headerlink" title="控制器的组成"></a>控制器的组成</h3><h4 id="指令部件"><a href="#指令部件" class="headerlink" title="指令部件"></a>指令部件</h4><blockquote><ul><li></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>夏令营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网 精简版本</title>
    <link href="/2022/08/01/3%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E9%9D%A2%E8%AF%95%E7%B2%BE%E7%AE%80%E7%89%88/"/>
    <url>/2022/08/01/3%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E9%9D%A2%E8%AF%95%E7%B2%BE%E7%AE%80%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>大学的遗物<br>主要是面向面试的版本</p><p>参考博客：</p><ol><li><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html</a></li></ol><p><strong>OSI分层    （7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p><strong>五层协议   （5层）</strong>：物理层、数据链路层、网络层、运输层、应用层。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>夏令营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数基础</title>
    <link href="/2022/08/01/2%20intership2022/"/>
    <url>/2022/08/01/2%20intership2022/</url>
    
    <content type="html"><![CDATA[<p>大学的遗物<br>跟随大四毕业实习课程进行的总结，不全面，基本的结构是差不多了</p><h1 id="数学概论"><a href="#数学概论" class="headerlink" title="数学概论"></a>数学概论</h1><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul><li><p>线性问题：数学对象之间的关系是以一次形式来表示</p></li><li><p>研究对象：标量（scalar）、向量（vector）、矩阵（matrix）</p></li><li><p>张量：计算当中的基本元素</p></li></ul><blockquote><p>线性变换</p><p>定义：设 $V_n，U_m$ 分别是 n 维和 m 维的线性空间，T 是一个从 $V_n$ 到 $U_m$ 的映射，如果映射满足两个性质：</p><p>（1）加和性：T(a1+a2)&#x3D;T(a1)+T(a2)</p><p>（2）齐次性：$\lambda$T($\alpha$) &#x3D;$\lambda$T($\alpha$)</p><p>则称T为线性变换。</p><p>线性代数可以看作是讨论空间变换与向量运动的科学，而空间变换与向量运动都是线性变换实现的</p><p>线性变换在深度学习中最直观的应用为通过矩阵乘法对图像或语音数据集进行增强。</p></blockquote><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h4><h4 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h4><p>任意矩阵与单位矩阵相乘等于原矩阵</p><h4 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h4><p>满足 $A^{-1}A&#x3D;I_n$</p><h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><p>满足 $AA^{T}&#x3D;A^{T}A&#x3D;I_n$，则称 A 为正交矩阵，且 $A^{-1}&#x3D;A^T$</p><p>正交矩阵都是行向量与列向量之间两两相交（向量点积为0）的单位矩阵</p><p>n 阶正交矩阵可以看作 n 维空间中任意相互垂直坐标基</p><p>向量乘以一个正交矩阵，可以看成对向量只做旋转，而没有伸缩和空间映射</p><h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p>出了对角线之外的元素都是0的矩阵</p><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>是将一个方阵映射到一个标量的函数，记作 det(A) 或 |A|</p><h4 id="行列式的含义"><a href="#行列式的含义" class="headerlink" title="行列式的含义"></a>行列式的含义</h4><ul><li>行列式等于矩阵特征值的乘积</li><li>行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或缩小了多少</li></ul><h3 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h3><h4 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h4><p>定义：设 A 是数据 k 上的 n 阶<strong>方阵</strong>，如果 $K^n$ 中有非零列向量 $\alpha$ 使得 $A\alpha&#x3D;\lambda\alpha$, 则称 $\lambda$ 是 A 的一个特征值，称 $\alpha$ 是 A 属于特征值 $\lambda$ 的一个特征向量。</p><p>一个矩阵对应着一种线性变换，通过矩阵乘法实现对向量的旋转、压缩和映射。</p><h4 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h4><p>利用特征值分解方阵</p><p>设<strong>方阵</strong> A 有 n 个线性无关的特征向量 $\alpha_n$，相对应的特征值为 $\lambda_n$ 则 A 的特征分解为：$$A&#x3D;Pdiag(\lambda)P^{-1}$$</p><h4 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h4><p>应用：图像压缩</p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><h3 id="随机实验"><a href="#随机实验" class="headerlink" title="随机实验"></a>随机实验</h3><p>满足以下三个特点的实验：</p><ul><li>可以在相同的条件下重复进行</li><li>每次实验的可能结果不止一个，并且能够事先明确实验的所有可能结果</li><li>进行一次试验之前不知道哪个结果会出现</li></ul><p>样本点：一个实验所有可能的结果的集合是样本空间，每个结果是一个样本点</p><p>随机事件：随机实验的某些样本点组成的集合</p><p>随机变量：本质是一个函数，是从样本空间的子集到实数集的一个映射，分为离散随机变量和连续随机变量。</p><h3 id="分布率"><a href="#分布率" class="headerlink" title="分布率"></a>分布率</h3><p>又称概率质量函数</p><h3 id="特殊离散分布"><a href="#特殊离散分布" class="headerlink" title="特殊离散分布"></a>特殊离散分布</h3><h4 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h4><p>也叫0-1分布，两点分布，随机变量 X 只可能取 0 和 1 两个值，分布律写作：</p><p>$$<br>P(X&#x3D;k)&#x3D;p^k(1-p)^{1-k},k&#x3D;0,1(0{\leq}p{\leq}1)<br>$$</p><h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>n 此伯努利分布满足的分布</p><p>若 X 表示 n 重伯努利实验中事件 A 发生的次数，则 n 此实验中实验 A 发生 k 次的概率为：</p><p>$$<br>P(X&#x3D;k)&#x3D;C^l_np^k(1-p)^{n-k},n&#x3D;0,1,…,n<br>$$</p><p>此时，称 X 服从参数 n，p 的二项分布，记作 X~B(n，p)，其中 E(X)&#x3D;np，Var(x)&#x3D;np(1-p)</p><h4 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h4><p>若随机变量所有的可能的取值为0，1，2，…，而取每个值的概率为：</p><p>$$<br>P(X&#x3D;K)&#x3D;\frac{\lambda^ke^{-\lambda}}{k!},k&#x3D;0,1,2,…<br>$$</p><p>则称 X 服从参数为 $\lambda$ 的泊松分布，记为 X~P($\lambda$)，其中 E(X)&#x3D;$\lambda$, D(X)&#x3D;$\lambda$，参数是单位时间或单位面积内随机事件的平均发生率</p><h3 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h3><h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><p>记作 X~N($\mu$,$\sigma^2$)</p><h3 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h3><p>多个变量组成的向量</p><h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><h4 id="条件概率、贝叶斯公式"><a href="#条件概率、贝叶斯公式" class="headerlink" title="条件概率、贝叶斯公式"></a>条件概率、贝叶斯公式</h4><p>X 是原因，Y 是结果（事件发生）。已知原因求解事件发生的概率通常被叫做条件概率，也叫做后验概率：</p><p>$$<br>P(Y|X)&#x3D;\frac{P(YX)}{P(X)}<br>$$</p><p>通常需要在已知事件发生的情况下计算 P(X|Y)，即是事件发生，分析导致事件发生的原因。此时如果还知道先验概率 P(X)，我们可以用 贝叶斯公式 计算：</p><p>$$<br>P(X|Y)&#x3D;\frac{P(XY)}{P(Y)}&#x3D;\frac{P(Y|X)P(X)}{P(Y)}<br>$$</p><p>分母可以利用全概率公式分解。</p><h2 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h2><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>典型的三种任务：</p><ul><li>分类：计算机程序需要指定输入属于 k 类中的哪一类。为了完成这个任务，学习算法通常会输出一个函数 f：$R^n-&gt;(1,2,…,k)$。计算机视觉中的图像分类算法解决的就是一个分类任务</li><li>回归：计算机程序会对给定输入来预测输出数值。学习算法通常会输出一个函数 $R^n-&gt;R$，这类任务的例子是预测投保人的索赔金额（用于设置保险费），或者预测证券未来的价格</li><li>聚类：对大量未知标注的数据集，按照数据的内在相似性，将数据划分为多个类别，类别内的数据相似度较大，类别间的相似性较小。可以用在土拍你检索，用户画像等场景</li></ul><p>分类和回归是预测问题的两个主要类型，占到 80-90%，分类的输出是离散的类别值，而回归的输出是连续数值</p><p>都是上课讲的，不想做笔记了</p><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="深度学习法则"><a href="#深度学习法则" class="headerlink" title="深度学习法则"></a>深度学习法则</h2><p>深度学习一般指深度神经网络，深度指神经网络的层数（多层）</p><p>深度神经网络分为：输出层、隐藏层、输入层</p><p>人工神经网络是指一种旨在模仿人类脑结构机器功能的信息处理系统。</p><p>单层感知机无法解决 XOR 问题，出现了多层感知机，也称为前馈神经网络</p><h2 id="深度学习训练法则"><a href="#深度学习训练法则" class="headerlink" title="深度学习训练法则"></a>深度学习训练法则</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度向量的方向，指向函数增长最快的方向，因此负梯度向量，指向函数下降最快的方向。</p><p>损失函数反映了感知器目标输出和实际输出之间的误差。最常用的误差函数是均方误差。一般均方误差更多用于回归问题，而交叉熵误差更多用于分类问题。</p><h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><p>信号正向传播，误差反向传播</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>sigmoid 函数 $f(x)&#x3D;\frac{1}{1+{e^{-x}}}$</p><p>tanh 函数 $f(x)&#x3D;\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}$</p><p>softsign 函数 $f(x)&#x3D;\frac{x}{|x|+1}$</p><p>上述函数会导致梯度消失问题。</p><p>softmax 函数</p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>减少泛化误差的一种方法。</p><p>防止过拟合最有效的方法是增加训练集合，训练集合越大，过拟合概率越小。</p><p>处理过拟合问题的一些重要正则化方法：L1正则、L2正则、数据集合扩充、Dropout、提前结束训练等方法</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>在梯度下降算法中，有各种不同的改进版本。在面向对象的语言实现中，往往把不同的梯度下降算法封装成一个对象，称为优化器。</p><p>算法改进的目的，包括但不限于：</p><ul><li>加快算法收敛速度</li><li>尽量避过或者冲过局部极值</li><li>减小手工参数的设置难度，主要是学习率</li><li>目前最常用的是 Adam 优化器</li></ul><h3 id="神经网络类型"><a href="#神经网络类型" class="headerlink" title="神经网络类型"></a>神经网络类型</h3><h4 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a>卷积神经网络CNN</h4><p>一种前馈神经网络，他的人工神经元可以响应一部分覆盖范围内的周围单元，对于图像处理有出色表现。它包括卷积层、池化层、全连接层。在模式分类领域，由于该网络避免对图像的复杂前期预处理，可以直接输入原始图像，得到广泛应用。</p><h4 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h4><p>通过隐藏层节点周期性的连接，来捕捉序列化数据中动态信息的神经网络，可以对序列化的数据进行分类。</p><p>存在梯度消失问题。</p><h4 id="生成对抗算法GAN"><a href="#生成对抗算法GAN" class="headerlink" title="生成对抗算法GAN"></a>生成对抗算法GAN</h4><p>这属于一种思想，分为生成器和判别器两部分。无监督学习。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>夏令营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++基础</title>
    <link href="/2022/07/27/1%20%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-c++/"/>
    <url>/2022/07/27/1%20%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-c++/</url>
    
    <content type="html"><![CDATA[<p>大学的遗物<br>从最开始基础开始，一直说到c++面向对象，主要参考菜鸟教程及网上博客</p><h1 id="c-简介"><a href="#c-简介" class="headerlink" title="c++简介"></a>c++简介</h1><h3 id="c-特性"><a href="#c-特性" class="headerlink" title="c++特性"></a>c++特性</h3><p>封装、抽象、继承、多态</p><h3 id="c-数据类型"><a href="#c-数据类型" class="headerlink" title="c++数据类型"></a>c++数据类型</h3><p>各种类型的存储大小与系统位数有关 </p><p>可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字:  <em>typedef type newname;</em></p><p>枚举类型<strong>enum</strong>是c++中的一种派生数据类型，用于枚举用户定义的若干常量的集合，表示一个变量的几种可能的值。默认情况下，枚举值从0开始递增，且可以自定义值大小。</p><h3 id="c-的变量类型"><a href="#c-的变量类型" class="headerlink" title="c++的变量类型"></a>c++的变量类型</h3><p>每个变量都有指定的类型，类型决定了变量存储的大小和布局。</p><p>可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。</p><p>需要分清变量的声明、定义和初始化。</p><p><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值表达式</p><p><strong>右值（rvalue）：</strong>术语右值指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</p><h3 id="c-的变量作用域"><a href="#c-的变量作用域" class="headerlink" title="c++的变量作用域"></a>c++的变量作用域</h3><p>局部变量（函数或代码块中声明的变量）、形式参数（函数参数中定义的变量）、全局变量（在所有函数外部声明的变量）</p><p>局部变量被定义时，系统不会对其进行初始化。全局变量定义时，系统回有一个默认的初始化（通常时全零）。</p><h3 id="c-的常量"><a href="#c-的常量" class="headerlink" title="c++的常量"></a>c++的常量</h3><p>常量就是固定值，也成为字面量。常量可以是任何基本数据类型，则整型、浮点值、字符、字符串和布尔值。</p><p>常见的前缀后缀如下所示：</p><table><thead><tr><th>进制</th><th>前缀</th></tr></thead><tbody><tr><td>八进制</td><td>0</td></tr><tr><td>十进制</td><td>无</td></tr><tr><td>十六进制</td><td>0x或者0X</td></tr></tbody></table><table><thead><tr><th>后缀</th><th>含义</th></tr></thead><tbody><tr><td>u或U</td><td>无符号整数</td></tr><tr><td>l或L</td><td>长整数</td></tr></tbody></table><p>浮点常量可以有小数形式和科学计数法形式。</p><p>布尔常量只有true和false，不应该true看成1，把false看成0。</p><p>字符常量常常扩在单引号中，\加上某些符号会形成转义字符。</p><p>字符串常量常常扩在双引号中，可以包含普通字符、转义字符和通用字符。</p><p>定义常量有两种方式：#define预处理器和const关键字。常量定义为大写字母形式，是一个很好的编程实践。</p><h3 id="c-的修饰符"><a href="#c-的修饰符" class="headerlink" title="c++的修饰符"></a>c++的修饰符</h3><p>signed、unsigned、long、short</p><h3 id="c-的函数"><a href="#c-的函数" class="headerlink" title="c++的函数"></a>c++的函数</h3><p>每个c++程序都至少有一个函数，即主函数main()。</p><p>函数组成部分：</p><ul><li>返回类型</li><li>函数名称</li><li>参数</li><li>函数主体</li></ul><p>函数声明：告诉编译器函数名称以及调用函数的方式。当在一个源文件中定义且在另一个文件中调用函数，函数声明是必须的。这种情况下，应该在调用函数的文件顶部声明函数。</p><p>函数调用：调用函数时，需要传递所需的参数。函数接受参数时，应该首先声明参数值的变量，这些变量称为<strong>形式参数</strong>。形参就像函数内的其它局部变量，在进入函数时被创建，退出函数时被销毁。函数调用有以下三种向函数传递参数的方式：</p><ul><li>传值调用：该方法把实际的值赋给函数形参。这种情况下，修改函数内的形参对实参没有影响</li><li>指针调用：该方法把参数的地址赋值给形参。在函数中，该地址用于访问调用中要用到的实参。这意味着，修改形参会改变实参。</li><li>引用调用：该方法的参数的引用赋值给形参。在函数内，该引用用于访问调用中要用到的实参。这意味着，修改形参回改变实参。</li></ul><p>默认情况下，c++用传值调用来传递参数，这意味着函数内的代码不能改变用于调用函数的参数。</p><p>当定义函数时，可以在参数列表后指定参数默认值。当调用函数时，如果实参的值留空，则使用这个默认值。</p><h4 id="lambda函数与表达式"><a href="#lambda函数与表达式" class="headerlink" title="lambda函数与表达式"></a>lambda函数与表达式</h4><p>c11对匿名函数提供支持，成为lambda函数。lambda函数把函数看成对象，lambda表达式可以像对象一样使用。比如可以将他们赋给变量作为参数传递，还可以向函数一样对其求值。</p><h3 id="c-数组"><a href="#c-数组" class="headerlink" title="c++数组"></a>c++数组</h3><p>存储一个固定大小的相同类型的顺序集合，特定元素可以通过索引的方式访问。</p><p>声明数组需要指定元素的类型和元素的数量。</p><h4 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h4><p>使用数组名作为常量指针时合法的，反之亦然。</p><p>对以下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> a[<span class="hljs-number">50</span>];<span class="hljs-comment">//声明数组</span><br><span class="hljs-type">double</span> *p;<span class="hljs-comment">//指针</span><br>p=a;<span class="hljs-comment">//将指针指向数组所在的地址</span><br>cout&lt;&lt;a[<span class="hljs-number">10</span>];<br>cout&lt;&lt;*(p<span class="hljs-number">+10</span>);<span class="hljs-comment">//两种访问方式</span><br></code></pre></td></tr></table></figure><h4 id="传递数组给函数"><a href="#传递数组给函数" class="headerlink" title="传递数组给函数"></a>传递数组给函数</h4><p>可以通过指定不带索引的数组名来传递一个指向数组的指针。</p><p>c++传数组给函数，数组类型自动转换成指针类型，因而传的实际是地址。</p><p>如果在函数中传递一个一维数组为参数，必须以以下三种方式来声明函数形参，且三种方式的结果一致，这是因为每种方式都会告诉编译器要接受一个指针。同样，也可以传递一个多为数组为形参。三种方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> p[<span class="hljs-number">10</span>])</span></span>&#123;&#125;<span class="hljs-comment">//指明大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> p[])</span></span>&#123;&#125;<span class="hljs-comment">//不指明大小</span><br></code></pre></td></tr></table></figure><p>就函数而言，数组的长度是无关紧要的，因为c++不对形参执行边界检查。</p><h4 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h4><p>c++不允许返回一个完整的数组作为参数的返回值。可以通过指定不带索引的数组名来返回一个指向数组的指针。如果要返回一个一维数组，必须声明一个返回指针的函数。如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//返回一个指针</span><br></code></pre></td></tr></table></figure><p>另外，c++不支持函数外返回局部变量的地址（考虑程序调用的堆栈使用情况，会被回收），除非定义局部变量为static变量。（静态变量的位置是在静态区，会在程序最开始就初始地址，一般具有和程序相同的生命周期。而局部变量存放在堆栈，即是动态区）</p><h3 id="c-字符串"><a href="#c-字符串" class="headerlink" title="c++字符串"></a>c++字符串</h3><h4 id="c风格字符串"><a href="#c风格字符串" class="headerlink" title="c风格字符串"></a>c风格字符串</h4><p>是使用null字符<strong>\0</strong>终止的一位字符数组。c++编译器会自动把\0 放在字符串的末尾，而不需要自己书写。</p><p>一些字符串操作函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">strcpy</span>(s1,s2);<span class="hljs-comment">//复制s2到s1</span><br><span class="hljs-built_in">strcat</span>(s1,s2);<span class="hljs-comment">//拼接s2到s1末尾，可以直接用加号</span><br><span class="hljs-built_in">strlen</span>(s1);<span class="hljs-comment">//返回字符串长度</span><br><span class="hljs-built_in">strcmp</span>(s1,s2);<span class="hljs-comment">//比较两个字符串</span><br><span class="hljs-built_in">strchr</span>(s1,ch);<span class="hljs-comment">//返回第一次出现ch的指针</span><br><span class="hljs-built_in">strstr</span>(s1,s2);<span class="hljs-comment">//返回第一次出现str的指针</span><br></code></pre></td></tr></table></figure><h4 id="c-的string类"><a href="#c-的string类" class="headerlink" title="c++的string类"></a>c++的string类</h4><p>它是一个类，用类的思想封装了很多字符串操作。</p><h3 id="c-指针"><a href="#c-指针" class="headerlink" title="c++指针"></a>c++指针</h3><p>每个变量都有一个内存位置，每个内存位置都定义了可使用连字号**&amp;**运算符访问的地址，这里又涉及到了字节对齐（为了使数据的存储和访问更加方便，采用字节对齐的方式，取为2的幂次地址）。</p><p>指针是一个变量，其值是一个地址。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p><p>一元运算符*****用来返回位于操作数所指定地址的变量的值。定义格式中指针变量前面的<code>“*”</code>，表示定义的变量的类型为指针型变量，<code>“*”</code>不是指针变量的一部分</p><p>如下将总结一些重要概念：</p><h4 id="Null指针"><a href="#Null指针" class="headerlink" title="Null指针"></a>Null指针</h4><p>在声明指针变量时，如果没有确切的地址可以赋值，为其赋值为Null是良好的习惯。指向Null的指针被成为空指针。</p><p>在大多数操作系统中，地址0的内存不允许被访问，被系统保留。同时，它具有非常重要的意义：表明指针不指向一个可以访问的内存地址。在程序中，要特别注意空指针的存在和使用。</p><h4 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h4><p>指针本质是用数值表示地址，因而可以用算术运算对其操作，支持，++，–，+，-。</p><p>指针增减的字节数目，应该根据指针的类型来确定。对于指向int的指针加一，地址应该+4，而指向char的指针加一，地址应该+1。</p><p>数组是一个常量指针，因此在程序中常常可以用一个变量指针来访问数组，访问时递增即可。</p><p>指针也可以用关系运算符进行比较。</p><h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><p>两者很多情况下可以相互替换的。但是也有特别的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span>  var[MAX] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>&#125;;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++)<br>   &#123;<br>      *var = i;    <span class="hljs-comment">// 这是正确的语法</span><br>      var++;       <span class="hljs-comment">// 这是不正确的</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把指针运算符 * 应用到 var 上是完全可以的，但修改 var 的值是非法的。这是因为 var 是一个指向数组开头的常量，不能作为左值。由于一个数组名对应一个指针常量，只要不改变数组的值，仍然可以用指针形式的表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">*(var + <span class="hljs-number">2</span>) = <span class="hljs-number">500</span>;<span class="hljs-comment">//正确例子</span><br></code></pre></td></tr></table></figure><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ptr[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>ptr声明为数组，由5个int指针组成。每个元素，都是指向int值的指针。</p><h4 id="指向指针的指针（多级间接寻址）"><a href="#指向指针的指针（多级间接寻址）" class="headerlink" title="指向指针的指针（多级间接寻址）"></a>指向指针的指针（多级间接寻址）</h4><p><img src="https://www.runoob.com/wp-content/uploads/2014/09/pointer_to_pointer.jpg%22%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88%22" alt="指向指针的指针"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> **var;<br></code></pre></td></tr></table></figure><p>同样的，访问这个值需要两个*。</p><p>这里只需要注意*和&amp;两个符号的含义即可。*是表示指针和访问指针指向的值两个作用，&amp;是将一个值本身存放的地址返回回来。</p><h4 id="传递指针给函数及返回指针"><a href="#传递指针给函数及返回指针" class="headerlink" title="传递指针给函数及返回指针"></a>传递指针给函数及返回指针</h4><p>传递指针也意味着可以传递数组作为参数。</p><p>注意，c++不支持返回局部变量的地址，除非定义为static变量（同上述返回数组）。</p><h3 id="c-引用"><a href="#c-引用" class="headerlink" title="c++引用"></a>c++引用</h3><p>引用变量是一个别名，它是一个已存在变量的另外一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或者变量名称来指向变量。</p><p><strong>引用和指针的区别</strong></p><ul><li>不存在空引用，引用必须连接到一个合法的内存。</li><li>一旦引用被初始化为一个对象，就不能指向到另一个对象。指针可以在任何时候指向另一个对象。</li><li>引用必须在创建时初始化。指针可以在任何时候初始化。</li></ul><p>可以用原始变量和引用来访问变量的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=<span class="hljs-number">11</span>;<span class="hljs-comment">//原变量</span><br><span class="hljs-type">int</span> &amp;r =i;<span class="hljs-comment">//创建引用</span><br></code></pre></td></tr></table></figure><h4 id="把引用作为参数和返回值"><a href="#把引用作为参数和返回值" class="headerlink" title="把引用作为参数和返回值"></a>把引用作为参数和返回值</h4><p>当返回一个引用时，引用的对象不能超出作用域，所以对一个局部变量引用是非法的。可以返回一个对于静态变量的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span></span>;<span class="hljs-comment">//参数是引用</span><br><br><span class="hljs-function"><span class="hljs-type">double</span>&amp; <span class="hljs-title">setValues</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; <span class="hljs-comment">//返回一个引用</span><br>   <span class="hljs-type">double</span>&amp; ref = vals[i];    <br>   <span class="hljs-keyword">return</span> ref;   <span class="hljs-comment">// 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c-指针和引用混讲"><a href="#c-指针和引用混讲" class="headerlink" title="c++指针和引用混讲"></a>c++指针和引用混讲</h3><ul><li><p>一个数组不能用另一个数组初始化，也不能将一个数组赋值给另一个数组。<a href="https://www.5axxw.com/questions/content/6tzgzk">解析</a></p></li><li><p>若指针保存0值，表明它不指向任何对象。但是把int型变量赋值给指针是非法的，尽管此int型变量的值可能为0，当然直接用int型变量给指针赋值也是非法的。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *p1 = <span class="hljs-number">0</span>;   <span class="hljs-comment">//right</span><br><span class="hljs-type">int</span> *p2 = a;   <span class="hljs-comment">//error</span><br><span class="hljs-type">int</span> *p3 = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> string *pstring; <br><span class="hljs-type">const</span> pstring cstr; <br></code></pre></td></tr></table></figure><ul><li>cstr的类型是 string * const 还是 const string * ？</li></ul><p>​答：是string *const cstr，而非 const string *cstr。容易产生误解的原因是const限定符既可以放在类型前也可以放在类型后，const pstring cstr等价于pstring const cstr。遇到此类问题时，把const放在类型之后来理解。</p><p>区分：int *ip[4] 和 int (*ip)[4]，第一个表示一个数组，元素是int指针；第二个表示一个指针，指向int数组，遇到此类问题时，由内向外读。<a href="https://zhidao.baidu.com/question/710897478821013445.html">解析</a></p><ul><li>关于值传递，指针传递，引用传递</li></ul><table><thead><tr><th align="left">值传递</th><th>指针传递</th><th>引用传递</th></tr></thead><tbody><tr><td align="left">形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</td><td>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作</td><td>形参相当于是实参的”别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</td></tr></tbody></table><ul><li>函数指针：指向函数的指针</li></ul><p>​函数指针的声明类似于函数的声明，只不过将函数名变成了 **(*指针名)**，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">int</span> (*fp)(<span class="hljs-type">int</span> a);<span class="hljs-comment">//函数声明</span><br>(*p)(<span class="hljs-number">5</span>);<span class="hljs-comment">//函数调用</span><br></code></pre></td></tr></table></figure><p>​这里就定义了一个指向函数(这个函数参数仅仅为一个 int 类型，函数返回值是 int 类型)的指针fp。</p><p>​这里东西太多，你把握不住的。</p><ul><li>vs2013中有这么一行代码，说明空指针的含义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">define <span class="hljs-literal">NULL</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​C++11标准后，用<strong>nullptr</strong>来表示空指针。</p><ul><li><p><strong>int&amp; r &#x3D; i;</strong> 和 <strong>int r &#x3D; i;</strong> 不同之处应该是内存的分配吧，后者会再开辟一个内存空间.</p></li><li><p>C++之所以增加引用类型， 主要是把它作为函数参数，以扩充函数传递数据的功能。引用和指针也很像，它们都不会创建副本，因此效率都很高。它们的主要区别在于：指针可能传递一个 NULL 过来，因此在使用前必须检查有效性；引用则必然代表某个对象，不需要做此检查。</p></li><li><p>用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。</p></li></ul><h1 id="c-面向对象"><a href="#c-面向对象" class="headerlink" title="c++面向对象"></a>c++面向对象</h1><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>定义一个类，本质上是定义一个数据类型的蓝图。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/05/cpp-classes-objects-2020-12-10-11.png,%22%E7%B1%BB%E5%AE%9A%E4%B9%89%22" alt="类定义"></p><p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。</p><h4 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h4><p>类的成员函数是指那些把定义和原型写在类定义内部的函数。</p><p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符 ::</strong> 来定义，在 :: 运算符之前必须使用类名。类定义中定义的成员函数把函数声明为内联的，即便没有inline关键字。<a href="https://blog.csdn.net/qq_33757398/article/details/81390151">内联函数指南</a></p><p><strong>::</strong> 叫作用域区分符，指明一个函数属于哪个类或一个数据属于哪个类。</p><p><strong>::</strong> 可以不跟类名，表示全局数据或全局函数（即非成员函数）。</p><ul><li>C++中函数调用非虚成员函数、调用虚函数的区别：</li></ul><p>​1.调用非虚成员函数：和调用非成员函数一样，通过对象确定对象所属的类，然后找到类的成员函数。此过程不会涉及到对象的内容，只会涉及对象的类型，是一种静态绑定。</p><p>​2.调用虚函数与调用非虚成员函数不同，需通过虚函数表找到虚函数的地址，而虚函数表存放在每个对象中，不能再编译期间实现。只能在运行时绑定，是一种动态绑定。</p><p><a href="https://blog.csdn.net/TABE_/article/details/122180181">虚函数指南</a></p><h4 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h4><p>封装是面向对象编程的重要特点，他防止函数直接访问类的内部成员。访问的权限（可见性）通过修饰符进行描述。默认是private。</p><table><thead><tr><th>修饰符</th><th>可见性</th></tr></thead><tbody><tr><td>private</td><td>外部不可见</td></tr><tr><td>protected</td><td>外部不可见，子类可访问</td></tr><tr><td>public</td><td>外部</td></tr></tbody></table><p>涉及到继承时，有三种继承方式，它们相应的改变了基类成员的访问属性，默认是private继承：</p><table><thead><tr><th align="left">继承方式</th><th align="left">基类的public成员</th><th align="left">基类的protected成员</th><th align="left">基类的private成员</th><th align="left">继承引起的访问控制关系变化概括</th></tr></thead><tbody><tr><td align="left">public继承</td><td align="left">仍为public成员</td><td align="left">仍为protected成员</td><td align="left">不可见</td><td align="left">基类的非私有成员在子类的访问属性不变</td></tr><tr><td align="left">protected继承</td><td align="left">变为protected成员</td><td align="left">变为protected成员</td><td align="left">不可见</td><td align="left">基类的非私有成员都为子类的保护成员</td></tr><tr><td align="left">private继承</td><td align="left">变为private成员</td><td align="left">变为private成员</td><td align="left">不可见</td><td align="left">基类中的非私有成员都称为子类的私有成员</td></tr></tbody></table><h4 id="类构造函数和析构函数"><a href="#类构造函数和析构函数" class="headerlink" title="类构造函数和析构函数"></a>类构造函数和析构函数</h4><p>类构造函数会在每次创建对象时执行。构造函数和类名完全相同，不返回任何类型（包括void）。构造函数用于为对象成员变量初始化。默认的构造函数没有任何参数，但如果需要，可以自定义带有参数的构造函数。可以使用初始化列表来初始化字段，等效于构造函数中赋值。</p><p>类的析构函数时一类特殊成员函数，他在每次删除创建的对象时执行。析构函数和类名完全相同，只需要加一个~作为前缀，不返回值，不能带有参数。析构函数有助于在跳出程序前释放资源。</p><p>一个类可以有很多个构造函数，带参不带参都可以，析构函数就一个。</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>特殊构造函数，利用同一个类之前创建的对象来初始化新创建的对象，具有单个形参，通常用const修饰，该形参是对该类类型的应用。通常用于：1、初始化新对象（显式调用）。 2、复制对象，以便将其作为参数传给函数（隐式调用）。 3、复制对象，并从函数中返回这个对象（隐式调用）。</p><p>编译器会自定义一个默认拷贝构造函数。如果类带有指针变量，并且有动态内存分配，则它必须有一个拷贝构造函数。其常见形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">classname</span> (<span class="hljs-type">const</span> classname &amp;obj)&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>关于为什么当类成员中含有指针类型成员且需要对其分配内存时，一定要有总定义拷贝构造函数？？</strong></p><p>默认的拷贝构造函数实现的只能是浅拷贝，即直接将原对象的数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。</p><p>这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间。</p><p>在某些情况下，浅拷贝回带来数据安全方面的隐患。</p><p>当类的数据成员中有指针类型时，我们就必须定义一个特定的拷贝构造函数，该拷贝构造函数不仅可以实现原对象和新对象之间数据成员的拷贝，而且可以为新的对象分配单独的内存资源，这就是深拷贝构造函数。</p><p><strong>如何防止默认拷贝发生</strong></p><p>声明一个私有的拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。</p><p><strong>总结：</strong></p><p>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。</p><p>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>类的友元函数是定义在类外部的，但有权访问私有成员和保护成员。尽管友元函数的原型在类的定义中出现过，但是友元函数并不是类的成员函数。友元可以是一个函数（友元函数），也可以是一个类（友元类）。友元类的所有成员都是友元。</p><p>声明一个函数是友元，需要在类定义中函数声明前加上关键字<strong>friend</strong>。</p><p>因为友元函数没有this指针，则其参数有三种情况：</p><ul><li>要访问非static成员，需要对象作为参数</li><li>要访问static成员或者全局变量，不需要对象作为参数，可以直接访问</li><li>如果参数的对象是全局对象，不需要对象作为参数</li></ul><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>如果一个函数是内联函数，编译时，编译器会把函数的代码副本放在啊每个调用函数的地方。这就导致每次需要修改内联函数，需要重新编译所有调用内联函数的客户端。内联函数的声明方法是使用关键字<strong>inline</strong>。类定义中的函数（类成员函数）都是内联函数。</p><p>内联函数是运用了<strong>空间换时间</strong>的思想。一般来说，内联函数都比较小。</p><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>每个对象都可以通过<strong>this</strong>指针来访问自己的地址。它是所有成员函数的隐含参数。友元因为不是类的成员，因此友元没有this指针。</p><ul><li>当我们调用成员函数时，实际上是替某个对象调用了它。成员函数通过一个名为this的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，调用<code>apple.show()</code>，编译器将apple的地址传递给show的隐式参数this，然后发生了调用。</li><li>this是一个常量指针，不允许修改。</li></ul><h4 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h4><p>使用<strong>static</strong>关键字把类成员定义成静态的。这意味着无论创建多少个类的对象，静态从成员都只有一个副本。并且它对于所有的对象都是共享的。如果没有初始化语句，默认会初始化为0。不能把静态成员的初始化放在类的定义中，但是可以再类的外部同各国范围解析运算符<code>::</code>重新声明静态变量从而对他初始化。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/05/cpp-static-members-2020-12-14.png" alt="类的静态成员"></p><p>把函数声明为静态时，即便没有类的对象也可以调用。静态函数只需要类名加上<code>::</code>即可访问。静态成员函数只能访问静态成员数据，其它静态成员函数和类外部的其它函数。静态成员函数不能访问类的this指针。</p><p>静态成员变量在类中仅仅是声明，而没有定义，所以需要在类外部定义，实际上是给静态成员变量分配内存，如果不加定义会报错。初始化时赋值，而定义时分配内存，定义比初始化多了一个物理上的含义。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是一种is a的关系，它是允许依据一种类来定义另一种类的方式。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/05/cpp-inheritance-2020-12-15-1.png" alt="类的继承"></p><p>c++支持多继承，以列表的形式排列。书写方式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape, <span class="hljs-keyword">public</span> PaintCost&#123;...&#125;<br></code></pre></td></tr></table></figure><p>另外多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式,格式：<code>class 类名: virtual 继承方式 父类名</code></p><p><strong>为什么子类的构造函数中会出现在初始化列表中呢？原因在于子类能够从基类集成的内容限制上。</strong></p><p>我们知道，一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><p>因此，我们不能够在子类的成员函数体中调用基类的构造函数来为成员变量进行初始化。</p><p>如子类构造函数如下是错误的：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Child: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Parent</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      Child(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b)<br>      &#123;<br>        Parent(a,b);<br>      &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以把基类的构造函数放在子类构造函数的初始化列表上，以此实现调用基类的构造函数来为子类从基类继承的成员变量初始化。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Child: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Parent</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      Child(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b):Parent(a,b)<br>      &#123;<br>        a=<span class="hljs-number">10</span>;<span class="hljs-comment">//flag</span><br>      &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同时，可以验证，初始化列表在flag行之前执行。</p><h3 id="重载运算符和重载函数"><a href="#重载运算符和重载函数" class="headerlink" title="重载运算符和重载函数"></a>重载运算符和重载函数</h3><p>在同一作用域中队某个函数或者运算符指定多个定义，即是重载函数和重载运算符。</p><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同的名称的声明，但是它们的参数列表和定义（实现）方式不同。当调用一个重载函数或者重载运算符时，编译器会将所有参数类型与定义中的参数类型进行比较，选择最合适的定义，选择处最合适的，成为重载决策。</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形参必须不同。不能仅仅通过返回值类型不同重载函数。</p><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>大部分内置的运算符都是可以重载的。重载的运算符是带有特殊名称的函数，函数名是关键字operator后跟待重载运算符，同样的，重载运算符需要一个返回值和一个参数列表。例如：<code>Box operator+(const Box&amp;)</code>这个声明是将两个Box对象相加，返回最终的Box对象。大多数的重载运算符可以被定义为非成员函数或者类成员函数。如果我们将上述的定义改成类的非成员函数，那么我们需要每次传递两个参数，如下所示<code>Box operator+(const Box&amp;, const Box&amp;);</code></p><p>值得注意的是:</p><ul><li>1、运算重载符不可以改变语法结构。</li><li>2、运算重载符不可以改变操作数的个数。</li><li>3、运算重载符不可以改变优先级。</li><li>4、运算重载符不可以改变结合性。</li></ul><p>类重载、覆盖、重定义之间的区别：</p><p>重载指的是函数具有的不同的参数列表，而函数名相同的函数。重载要求参数列表必须不同，比如参数的类型不同、参数的个数不同、参数的顺序不同。如果仅仅是函数的返回值不同是没办法重载的，因为重载要求参数列表必须不同。（发生在同一个类里）</p><p> 覆盖是存在类中，子类重写从基类继承过来的函数。被重写的函数不能是static的。必须是virtual的。但是函数名、返回值、参数列表都必须和基类相同（发生在基类和子类）</p><p> 重定义也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) 。（发生在基类和子类）</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p><p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p><p>C++中**, 虚函数**可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。</p><p>一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。</p><p>编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！</p><p><strong>纯虚函数</strong>可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>c++接口用抽象类实现，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类(ABC)。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">// 纯虚函数</span><br>      <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">getVolume</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;      <span class="hljs-comment">// 长度</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。</p><h3 id="重写重载多态混讲"><a href="#重写重载多态混讲" class="headerlink" title="重写重载多态混讲"></a>重写重载多态混讲</h3><p>一个有趣的说法是：继承是子类使用父类的方法，而多态则是父类使用子类的方法。</p><p>重写(override):继承的时候覆盖父类的方法，重新实现一个函数体。</p><p>重载(overload):在一个类中间，同名函数参数列表不同。</p><p>多态：动态绑定。</p><p>函数的重载、运算符重载都是多态现象。 从系统实现的观点看，多态性分为两类：静态多态和动态多态性。以前学过的函数重载和运算符重载属于静态多态性，在编译程序时系统就可以确定调用哪个函数，因此静态多态性又称编译时的多态性。静态多态性是通过函数重载实现的。动态多态性是在程序运行中才能确定操作所针对的对象。它又称运行时的多态性。动态多态性是通过虚函数实现的。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>夏令营</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
